//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//          PPPPP  H   H  EEEEE  N    N  GGGGG  L      EEEEE  III         +
//          P   P  H   H  E      NN   N  G      L      E       I          +
//          PPPPP  HHHHH  EEEEE  N N  N  G  GG  L      EEEEE   I          +
//          P      H   H  E      N  N N  G   G  L      E       I          +
//          P      H   H  EEEEE  N    N  GGGGG  LLLLL  EEEEE  III         +
//------------------------------------------------------------------------+
//          Platform for Hybrid Engineering Simulation of Flows           +
//          China Aerodynamics Research and Development Center            +
//                     (C) Copyright, Since 2010                          +
//                         PHengLEI 2506                                  +
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
###########################################################################
#                       Default parameters for Grid conversion            #
###########################################################################
// gridtype: Grid type for generation, conversion, reconstruction, merging.
//             0 -- Unstructured grid.
//             1 -- Structured grid.
//             2 -- Hybrid grid, include both of unstructured and structured grid.
// gridobj: Task type of grid treatment.
//             0 -- Grid generation of typical case, such as cylinder, flat plate, etc.
//             1 -- Grid conversion, from other grid data to PHenglEI, such as Fluent, CGNS.
//             2 -- Grid refinement.
//             3 -- Grid merging, merge two blocks into one block.
//             4 -- Grid deformation, achieve unstructured grid deformation.
//             5 -- Grid repairing, repair the original grid in order to remove the negative volume cells.
//             6 -- Grid mirroring, mirror a symmetry grid to whole grid.
//             7 -- Grid type change, convert structured grid to unstructured grid.
// multiblock: Multi-block grid or not, only for structured grid conversion.
//             0 -- Not.
//             1 -- Yes.
// iadapt: Adaptation number for unstructure grid.
// SymmetryFaceVector: The vector of symmetry face.
//             0 -- X axis.
//             1 -- Y axis.
//             2 -- Z axis.
// gridReorder: Reorder cell and face of grid or not, only for 3D unstructured grid conversion,
//              which is CGNS type.
//             0 -- Not.
//             1 -- Yes.
// faceReorderMethod: the reorder method face of unstructured grid.
//             0 -- BSFCELLFACEORG.
//             1 -- BSFCELLFACELEFT. 
//             2 -- BSFCELLFACERIGHT.
int gridtype            = 0;
int gridobj             = 1;
int multiblock          = 0;
int iadapt              = 0;
int SymmetryFaceVector  = 1;
int gridReorder         = 0;
int faceReorderMethod   = 0;

// nAxisRotateTimes: number of axis rotating times, zero (default) meaning without rotating.
// axisRotateOrder : axis rotating order. The size of array "axisRotateOrder" is equal to nAxisRotateTimes.
//             1 -- X-axis.
//             2 -- Y-axis.
//             3 -- Z-axis.
// axisRotateAngles: axis rotating angles (degree), which are corresponding to the axis rotating order. 
int nAxisRotateTimes      = 0;
int axisRotateOrder[]     = [1, 2, 3];
double axisRotateAngles[] = [0.0, 0.0, 0.0]; 

// omit_no_bound_bc: What's boundary condition for the type of "no_boundary_condition".
//                   0 -- Interface. (default)
//                   1 -- Physical boundary condition, used in Hybrid solver.
int omit_no_bound_bc = 0;
int omitRepeatInterface = 1;

//-----------------------------------------------------------------------
#                           Grid data type                              #
//-----------------------------------------------------------------------
// from_gtype/to_gtype: Type of grid data type in grid conversion process.
//                     -1 -- MULTI_TYPE.
//                      1 -- PHengLEI, *.fts.
//                      2 -- CGNS, *.cgns.
//                      3 -- Plot3D type of structured grid, *.dat/*.grd.
//                      4 -- Fieldview type of unstructured grid, *.dat/*.inp.
//                      5 -- Fluent, *.cas/*.msh.
//                      6 -- Ustar, mgrid.in.
//                      7 -- Hybrid, include both of unstructured and structured grid, *.fts.
//                      8 -- GMSH, *.msh.
//                      9 -- Gridgen type of structured grid, *.dat/*.grd.
// dumpOldGrid: If dump out the old grid file.
//              0 -- Not. (default)
//              1 -- Yes.
int from_gtype  = 2;
int to_gtype    = 1;
int dumpOldGrid = 0;

//-----------------------------------------------------------------------
#                           File path                                   #
//-----------------------------------------------------------------------
// from_gfile: path of original data file for unstructure grid convert from.
// out_gfile:  path of target file for grid convert to, *.fts type of file usually.
int numberOfGridFile = 1;
string from_gfile    = "./grid/rae2822_hybrid2d.cas";
string from_gfile1   = "";
string out_gfile     = "./grid/flat_laminr_133_85_2d.fts";

// ----------------- some advanced choices ------------------------------
// iunsteady: The Grid is for unsteady simulation or not.
int iunsteady = 0;

// fileformat: Ustar Grid file format.
//             0 -- BINARY.
//             1 -- ASCII.
int fileformat = 0;

// Parameters for hybrid solver.
// mixgrid_uns: path of unstructure grid file for hybrid solver, *.fts type.
// mixgrid_str: path of structure   grid file for hybrid solver, *.fts type.
string mixgrid_uns = "./grid/rae2822_uns2d_4.fts";
string mixgrid_str = "./grid/flat_laminr_133_85_2d.fts";

// Some parameters for structured overlapping grid.
int    codeOfDigHoles      = 1;
string holeBasicFileName   = "./oversetGridView/holeBasicFile.inp";
string holeFullFileName    = "./oversetGridView/holeFullFile.dat";
string linkFileName        = "./oversetGridView/topology.dat";
string zoneInverseFileName = "./oversetGridView/zoneInverseMapping.inp";

// ----------------- Grid Refine Parameters -----------------------------
// anisoRefine: If refine grid by anisoRefine type.
//              0 -- Not. (default)
//              1 -- Yes.
// geometryUnit: Geometry unit.
//              1 -- meter.
//              2 -- millimeter.
//              3 -- inch.
// exclusiveCase: Parallel projection exclusive case.
//              0 -- NON case.
//              1 -- JSM-C2-NPOFF case.
//              2 -- CHNT.
// projectOrgPoint: If the original wall points need to be projected or not.
int anisoRefine     = 0;
int geometryUnit    = 1;
int isProject       = 0;
int readDist        = 0;
int isDeform        = 0;
int exclusiveCase   = 0;
int projectOrgPoint = 0;
string geometryFileName = "./grid/jsm.igs";

// ----------------- Grid Deform Parameters -----------------------------
// deformationMethod: Grid Deform.
//                    1 -- SPRING.
//                    2 -- RBF.
// stationalGridFile: Original grid file.
// visualFileName   : The visualization file path of deform grid.
// nDeformStep      : The max deform step.
// flapAngle        : The max flap angle.
// rotatePostionZ   : Rotate postion.
// rotatePostionY   : Rotate postion.
// gridSlice        : If dump slice grid.
// sliceAxis        : Grid slice axis.
// slicePosition    : Grid slice position.
int    nDeformStep    = 40;
double flapAngle      = 10.0;
double rotatePostionZ = 4.00003;
double rotatePostionY = 3.05;

int    deformationMethod = 2;
string stationalGridFile = "./grid/Segment2Brid.fts";
string visualFileName    = "./results/deformedGrid.dat"

int    gridSlice     = 1;
int    sliceAxis     = 1;
double slicePosition = 13;

// ----------------- RBF Parameters -------------------------------------
// numberOfReferenceCP: Number of reference Control Points.
// influencePara      : The RBF influence radius parameter.
int numberOfReferenceCP = 40;
double influencePara    = 25.0;

// ----------------- Periodic Parameters --------------------------------
// Notice: Rotational periodicity only support rotation along the X axis!
// periodicType: Which periodic boundary is used.
//               0 -- without Periodic Boundary.
//               1 -- Translational periodicity.
//               2 -- Rotational periodicity.
// translationLength[]: The relative distance between two periodic face
                        which only support one direction.
// rotationAngle: The relative angle between two periodic face.
                  which is recorded in degrees.  
int periodicType = 0; 
double translationLength[] = [0.0, 0.0, 0.0];
double rotationAngle = 0.0;

#########################################################################
#                       Default parameters for Partition                #
#########################################################################
// pgridtype: The grid type.
//            0 -- unstruct grid.
//            1 -- struct grid.
//            2 -- refine structured grid.
// maxproc: The number of partition zones that want to be divided into.
// numberOfMultifile: The number of partition grid files that want to be dumped out.
int pgridtype = 0;
int maxproc   = 4;
int numberOfMultifile = 1;

// traceMark: Trace mark or not, only for structured grid partition.
//            0 -- Not.
//            1 -- Yes.
// blockIndexOfMark: the block index of mark, only for structured grid partition.
// cellIndexOfMark : the cell  index of mark, only for structured grid partition.
int traceMark        = 0;
int blockIndexOfMark = 0;
int cellIndexOfMark[] = [185, 30, 1];

// parallelStrategy:
//            0 -- each zone is assigned to the one that defined in grid partition procedure.
//            1 -- random assigned for each zone or by some else ways.
int parallelStrategy = 1;

//-----------------------------------------------------------------------
#                           File path                                   #
//-----------------------------------------------------------------------
// original_grid_file:  Original grid file that want to be divided(PHengLEI type, *.fts).
// partition_grid_file: Target partition grid file(PHengLEI type, *.fts).
string original_grid_file  = "./grid/sphere_mixed.fts";
string partition_grid_file = "./grid/sphere_mixed__4.fts";

// ------------------ Sompe advanced parameters -------------------------
// omit_no_bound_bc: What's boundary condition for the type of "no_boundary_condition".
//                   0 -- Interface. (default)
//                   1 -- Physical boundary condition, used in Hybrid solver.
// npartmethod: Method of interface reconstruction, default is 1.
// parallelPartitionMethod: Method of parallel partition, this is set only when execute parallel partition. It would be skipped when serial partition.
//                   1 -- Using ParMetis for homogeneous MPI.
//                   2 -- Using Metis for homogeneous MPI.
//                   3 -- using METIS partition for homogeneous OpenMP.
// parmetisBalance: Used to specify the imbalance tolerance.
//                   1 -- perfect balance.
//             maxproc -- perfect imbalance.
//                1.05 -- recommended.
int omit_no_bound_bc        = 0;
int npartmethod             = 1;
int parallelPartitionMethod = 2;
double parmetisBalance      = 1.05;

// numberOfMultigrid: Number of multi-grid levels, ONLY used for structured grid.
//                    1 -- single level.
//                    2 -- 2 level.
//                    N -- N level, ..., et al.
int numberOfMultigrid = 1;

#########################################################################
#                     Default parameters for CFD simulation             #
#########################################################################
// maxSimuStep: The max simulation step, don't care simulation is restart or not.
// intervalStepFlow:   The step intervals for flow variables file 'flow.dat' saved.
// intervalStepPlot:   The step intervals for tecplot visual file 'tecflow.dat' saved.
// intervalStepSample: The step intervals for monitored probes variables file 'sample.dat' saved.
// intervalStepForce:  The step intervals for aerodynamics coefficients file 'aircoef.dat' saved.
// intervalStepRes:    The step intervals for residual file 'res.dat' saved.
int maxSimuStep        = 20000;
int intervalStepFlow   = 1000;
int intervalStepPlot   = 1000;
int intervalStepSample = 1000;
int intervalStepForce  = 100;
int intervalStepRes    = 10;

// compressible:
//               0 -- incompressible flow.
//               1 -- compressible flow. (default)
int compressible = 1;

// ifLowSpeedPrecon: Precondition process to accelerate convergence for low speed flow.
//                   0 -- no precondition process. (default, mach > 0.3)
//                   1 -- carry out precondition process. (mach number <= 0.3)
// Kprec: The coefficient K for the cut-off velocity.
//        1.0~3.0 is suggested. (default, 3.0)
// preconFarfieldBCMethod: The precondition method for farfield boundary condition.
//                         0 -- precondition far-field boundary based on riemann invariants. 
//                         1 -- Turkel's simplified far-field boundary condition.
int ifLowSpeedPrecon = 0;
double Kprec = 3.0;
int preconFarfieldBCMethod = 1;
double refLengthOfLowSpeed = 1.0;

//-----------------------------------------------------------------------
#                           CFD Control Parameter                       #
//-----------------------------------------------------------------------
// refMachNumber: Mach number.
// attackd: Angle of attack.
// angleSlide: Angle of sideslip.
// inflowParaType: The type of inflow parameters.
//                 0 -- the nondimensional conditions.
//                 1 -- the flight conditions.
//                 2 -- the experiment conditions.
//                 3 -- the subsonic boundary conditions. (Useless!)
//                 4 -- the condition that the velocity, temperature and density are given.
//                 5 -- the condition that the velocity, temperature and pressure are given.
//flowInitMethod: Flow field initialization method.
//                 0 -- The entire flow field is initialized according to Infinite velocity.
//                 1 -- The velocity near the wall is initialized according to the boundary layer of the plate.
//                 2 -- The entire flow field is initialized by flowInitStep iterations of FirstOrder method.
//                 3 -- The entire flow field is initialized by flowInitStep iterations of LUSGS method.
// refReNumber: Reynolds number, which is based unit length, unit of 1/m.
// refDimensionalTemperature: Dimensional reference temperature, or the total temperature only for the experiment condition.
// freestream_vibration_temperature: Dimensional freestream vibration temperature.
// refDimensionalPressure: Dimensional reference pressure, or the total pressure only for the experiment condition.
// height: Fly height, unit of km.
// wallTemperature: Temprature of the solid wall, minus value is for adiabatic boundary condition.
// gridScaleFactor: The customizable unit of the grid, default value is 1.0 for meter. Common dimensions like:
//                 1 dm = 0.1 m.
//                 1 cm = 0.01 m.
//                 1 mm = 0.001 m.
//                 1 inch = 0.0254 m.
//                 1 foot = 12 inches = 0.3048 m.
//                 1 yard = 3  feet   = 0.9144 m.
// forceReferenceLength, forceReferenceLengthSpanWise, forceReferenceArea: Reference length, SpanWise length and area, independent of grid unit.
// TorqueRefX, TorqueRefY, TorqueRefZ: Reference point, independent of grid unit.
// radiationCoef: The radiation coefficient on wall, it is used to compute the radiation heat flux on wall when the boundary
//                condition is radiation equilibrium temperature, and 0.8 is the default value.
// refMolecularWeight: the reference molecular weight of gas used for perfect gas. The unit is g/mol.
// Generally, the gas is air. Sometimes, it is experiment gas, such as Nitrogen, Argon, and so on.
int directionMethod  = 0;
double refMachNumber = 0.73;
double attackd       = 2.79;
double angleSlide    = 0.00;
int flowInitMethod = 0;

int inflowParaType = 0;
double refReNumber = 6.5e6;
double refDimensionalTemperature = 288.15;
double freestream_vibration_temperature = 300.00;

//int inflowParaType = 1;
//double height = 0.001;

//int inflowParaType = 2;
//double refDimensionalTemperature = 6051.024;    // The total temperature, T*(1+(refGama-1)*M*M/2).
//double refDimensionalPressure = 4.299696E09;    // The total pressure, p*(T0/T)^(refGama/(refGama-1)).

// The velocity, temperature and density are fixed.
//int inflowParaType = 4;
//double refDimensionalVelocity = 1000.0;
//double refDimensionalDensity  = 1.0e3;

// The velocity, temperature and pressure are fixed.
//int inflowParaType = 5;
//double refDimensionalVelocity = 1000.0;
//double refDimensionalPressure = 1.0e5;

// The MachNumber, temperature and pressure are fixed.
//int inflowParaType = 6;
//double refDimensionalTemperature = 293.0;
//double refDimensionalPressure = 8886.06;

// The velocity, temperature and pressure are read from file.
//int inflowParaType = 7;
//string weatherDataFilePath   = "./WRFData/";
//double longitude = 110.95    
//double latitude = 19.61;

// The is calculated by an exponential or logarithmic  function, temperature and pressure are fixed.
//int inflowParaType = 8;
//int windProfileType = 0;
//double refDimensionalGroundVelocity = 15;
//double refDimensionalHeight = 10;
//double powerLawCoefficient = 0.25;
//int windProfileType = 1;
//double refDimensionalFrictionVelocity = 0.4;
//double refDimensionalRoughLength = 0.3;
//double logarithmicLawKappa = 0.41;
//double refDimensionalVelocity = 8;
//double refDimensionalPressure = 101325;
//double refDimensionalTemperature = 288.15;

double wallTemperature = -1.0;

double radiationCoef = 0.8;
double gridScaleFactor = 1.0;
double gridTranslationVector[] = [0.0, 0.0, 0.0];

int numberOfAerodynamicForceComponents = 1;
double forceReferenceLengthSpanWise = 1.0;    // unit of meter.
double forceReferenceLength = 1.0;            // unit of meter.
double forceReferenceArea = 1.0;              // unit of meter^2.
double TorqueRefX = 0.0;                      // unit of meter. 
double TorqueRefY = 0.0;                      // unit of meter.
double TorqueRefZ = 0.0;                      // unit of meter.
double knudsenLength = 1.0;		          // unit of meter.
double refMolecularWeight = 28.9644;          // unit of g/mol.

//-----------------------------------------------------------------------
#                           Spatial Discretisation                      #
//-----------------------------------------------------------------------
#************************************************************************
#                         Struct Solver                                 *
#************************************************************************
// inviscidSchemeName: Spatial discretisation scheme of struct grid.
//                     Using this when solve structered grid or hybrid.
//                     -- "vanleer", "steger", "hlle", "lax_f",
//                     -- "roe", "modified_roe",
//                     -- "ausm+", "ausm+w", "ausm+up", "ausmdv", "ausmpw", "ausmpw+".
// isWennScheme: If using WENN Scheme of struct grid.
//                   0 -- NO. (default)
//                   1 -- Yes.
// str_limiter_name: Limiter of struct grid.
//                     -- "vanalbada", "vanleer", "minmod", "smooth", "minvan", "3rdsmooth", "3rd_minmod_smooth",
//                     -- "nolim", no limiter,
//                     -- "vanalbada_clz", clz supersonic version,
//                     -- "weno3_js", "wenn3_prm211", "wenn3_zm", "wenn3_zes2", "wenn3_zes3".
string inviscidSchemeName = "roe";
int isWennScheme = 0;
string str_limiter_name = "vanalbada";

#************************************************************************
#                         UnStruct Solver or Common                     *
#************************************************************************
// viscousType: Viscous model.
//              0 -- Euler.
//              1 -- Laminar.
//              2 -- Algebraic.
//              3 -- 1eq turbulent.
//              4 -- 2eq turbulent.
// viscousName: Laminar or tubulent model.
//              -- "0eq-bl".
//              -- "1eq-sa".
//              -- "2eq-kw-menter-sst".
//              -- "2eq-kw-menter-bsl".
//              -- "2eq-kw-wilcox-1988".
//              -- "2eq-kw-wilcox-1998".
//              -- "2eq-kw-kok-tnt".
//              -- "2eq-kw-wilcox-2006".
//              -- "easm-kw-2003".
//              -- "easm-kw-2005".
// DESType: Type of DES.
//          0 -- RANS. (default)
//          1 -- DES.
//          2 -- DDES.
//          3 -- IDDES.
// uns_scheme_name: Spatial discretisation scheme of Unstruct grid.
//                  Using this when solve Unstructered grid or hybrid.
//                  -- "vanleer", "roe", "GMRESRoe", "GMRESSteger", "steger", "kfvs", "lax_f", "hlle",
//                  -- "ausm+", "ausmdv", "ausm+w", "ausmpw", "ausmpw+".
// uns_limiter_name: Limiter of Unstruct grid.
//                   -- "barth", "vencat", "vanleer", "minmod",
//                   -- "vanalbada", "smooth", "nnd", "lpz", "1st",
//                   -- "nolim", no limiter.
// uns_vis_name: Discretisation method of viscous term.
//               -- "std", "test", "aver", "new1", "new2".
// gradientName: Gradient reconstruction method.
//               -- "default", "ggcell", "ggnode", "lsq".
// ivencat: Variation of vencat limiter.
//          0 -- org method, it is independent of grid scale.
//          1 -- new method, it is dependent of grid scale.
//          4 -- Ustar limiter model, without grid size unitary.
//          7 -- default used.
// venkatCoeff: Cofficient of vencat, when using vencat limter.
// limitVariables: Limit model (It is useful only if limitVector is 0).
//                 0 -- limit only for pressure and denstiny, then get the min value.
//                 1 -- limit for every variables, then get the min value.
// limitVector:
//              0 -- Each variable use the same limiter coefficient.
//              1 -- Each variable use the respective limiter coefficients.
// reconmeth:
//              0 -- When reconstruct face value, Q+, Q- use respective limiter coefficients.
//              1 -- Q+, Q- use the min limiter coefficients of left and right cell.
// skewnessAngle: The skewness angle of grid cells.
// roeEntropyFixMethod: Entropy fix (correction) method.
//              1 -- direct fix, which limits the minimum eigenvalue directly.
//              2 -- multi-dimensional fix, which is derived from structured solver and now is only valid for struct solver.
//              3 -- Harten type, which is default used.
// roeEntropyScale: Entropy fix (correction) coefficient scale, default is 1.0.
//                  It is used to scale the default Roe entropy fix coefficients.
// AusmpwPlusLimiter: A Limiter to make "function w" not change acutely in AusmpwPlus scheme, default is 1.0.
// isTurbulenceModelCorrect: Whether to use AI algorithms for the correction of turbulence models.
//              0 -- No.
//              1 -- Yes.
//int    viscousType = 0;
//string viscousName = "Euler";

//int    viscousType = 1;
//string viscousName = "laminar";

int    viscousType = 3;
string viscousName = "1eq-sa";

//int    viscousType = 4;
//string viscousName = "2eq-kw-menter-sst";

int isTurbulenceModelCorrect = 0;

int DESType = 0;

string uns_scheme_name  = "roe";
string uns_limiter_name = "vencat";
string uns_vis_name     = "test";
string gradientName     = "ggnode";

int ivencat = 7;
double venkatCoeff = 5.0;
int reconmeth      = 1;
int limitVariables = 0;
int limitVector    = 0;
double skewnessAngle = 60.0;
double turbSkewnessAngle = 0.0;

int roeEntropyFixMethod = 3;
double roeEntropyScale  = 1.0;

double AusmpwPlusLimiter = 1.0;

#************************************************************************
#                       Temporal Discretisation                         *
#************************************************************************
// iunsteady: Steady or unsteady.
//            0 -- steady.
//            1 -- unsteay.
// physicalTimeStep: The nondimensional physical time step.
// ifStartFromSteadyResults: The unsteady simulation is start from steady flowfield or not, 0 is for no and else is for yes.
// ifStaticsFlowField: Statistical variables for unsteady simulation.
// ifStaticsReynoldsStress: Statistical Reynolds stress for unsteady simulation.
// startStatisticStep: Outer step when start statistics.
//                     when the value is larger than "maxSimuStep", it is useless.
// statisticalTimePeriod: Used as time period of statistic analysis.
//                        when the value is negative, time period is treated as infinite.
// statisticMethod: Statistic reynolds stress method.
//                  0 -- tau = <q^2> - <q>^2
//                  1 -- tau = <u'u'>
// min_sub_iter: The min sub iteration of unsteady simulation.
// max_sub_iter: The max sub iteration of unsteady simulation.
// tol_sub_iter: The tolerance of sub iteration of unsteady simulation.
// tscheme: Temporal Discretisation method.
//          1 -- Runge-Kutta Multi-State.
//          2 -- Point implicit.
//          3 -- Full implicit.
//          4 -- LU-SGS.
//          5 -- Block LU-SGS.
//          6 -- Jacobian iteration.
//          7 -- Line LU-SGS.
//          8 -- Matrix LU-SGS.
//          9 -- GMRES.
// iSimplifyViscousTerm: Simplify the computation of viscous term in the Block LU-SGS method. The default value assigns 1 that could speed up the computation.
//                       Otherwise, the viscous Jacobian matrix Mv should be computed that will increase the memory and time in iteration of the BLUSGS method.
// CFLMethod: The method to compute cfl number.
//                 0 -- Linear change.
//                 1 -- Exponential change.
// CFLStart: Started cfl number.
// CFLEnd: End cfl number.
// CFLVaryStep: The number of step when cfl increase from CFLStart to CFLEnd.
// GMRESCFLScale : CFL = CFLStart * GMRESCFLScal^iteration.
// OriginalTscheme : Used for LUSGS and GMres hybrid computing.
// ktmax: Dtratio. dt[i] = MIN(dt[i], ktmax * dtmin / vol[i])
// swapDq: Communication dq between forward/backward sweep of LUSGS or not, default is 0.
// nLUSGSSweeps: Sub iteration of LU-SGS or Block LU-SGS.
// LUSGSTolerance: Sub iter tolerance of LU-SGS or Block LU-SGS.
// ifLocalTimeStep: Time step method.
//                 0 --Local.
//                 1 --Global.
// isUseLocalCFL: use variable number of CFL or not.
//                 0 -- global unified CFL number.
//                 1 -- local CFL number.
// isUsePreTwall: use the previous temperatures on wall. 1 indicates yes, and 0 indicates no.
// visl_min: Minimum value of laminar viscosity coefficient.
// turbCFLScale: Turbulence model cfl number factor.
// codeOfAleModel: Arbitrary Lagrangian-Eulerian method.
//                 0 -- no ALE method.
//                 1 -- ALE method for non-moving grids.
//                 2 -- ALE method for moving grids.
//                 3 -- ALE method for deforming grids.
// wallFunctionType: The type of wall function to implement.
//                 0 -- no wall function. (default)
//                 1 -- standard wall function.
//                 2 -- Pab3D wall function.
// RKStage: The number of Runge-Kutta step.
// lamda: Cofficient of Runge-Kutta step.
int    iunsteady = 0;
double physicalTimeStep = 0.01;
double physicalTimeStepDimensional = -0.001;
int    ifStartFromSteadyResults = 0;
int    ifStaticsFlowField = 0;
int    ifStaticsReynoldsStress = 0;
int    startStatisticStep = 800000;
double statisticalTimePeriod = -1.0;
int    statisticMethod = 0;
int    linearTwoStepMethods = 1;    // 1--BDF1; 2--C-N; 3--BDF2.

int    methodOfDualTime = 3;
int    min_sub_iter = 50;
int    max_sub_iter = 50;
double tol_sub_iter = 0.01;

int    tscheme = 4;
int    iSimplifyViscousTerm = 1;
int    ifLocalTimeStep = 0;
int    isUseLocalCFL = 0;
int    isUsePreTwall = 0;

int    cflMethod   = 0;
double CFLStart    = 0.01;
double CFLEnd      = 10.0;
int    CFLVaryStep = 500;
double GMRESCFLScale = 1.0;
int    OriginalTscheme = 0;
double pMaxForCFL = 0.2;
double pMinForCFL = 0.1;
double deltaMaxForCFL = 0.2;
double magnifyFactorForCFL = 1.1;
double reduceFactorForCFL = 0.5;

double ktmax = 1.0e10;

int    swapDq = 1;

int    nLUSGSSweeps = 1;
double LUSGSTolerance = 0.01;
int    order = 2;

double visl_min = 0.01;
double turbCFLScale = 1.0;
double csrv     = 1.0;
double timemax  = 1.0e10;
double dtsave   = -1.0;
int    maxale   = 10;
double dtau     = 0.001;

int wallFunctionType = 0;

int RKStage    = 2;
double lamda[] = [0.5, 1.0];

//int RKStage    = 1;
//double lamda[] = 1.0;

//int RKStage    = 4;
//double lamda[] = [0.25, 0.33333333333, 0.5, 1.0];

#************************************************************************
#                         Porous medium Parameter                      *
#************************************************************************
// isPorousZone: Is porous medium area or not.
//            0 -- no.
//            1 -- yes.
// viscousResistanceCoeff[]: The coefficient of viscous resistance in different directions, unit of 1/m^2.
// inertialResistanceCoeff[]: The coefficient of inertial resistance in different directions, unit of 1/m.
// porosity: The porosity of porous media.
// densitySolid: The solid density of porous media, unit of kg/m^3.
// cpSolid: The species constant pressure specific heat of porous media, unit of J/(kg·K).
// kSolid: The heat conductivity coefficient, unit of W/(m·K)‌.

int isPorousZone = 0;
double viscousResistanceCoeff[] = [4.2e8 0.0 0.0];
double inertialResistanceCoeff[] = [6.349 1.0 1.0];
double porosity = 1.0;
double densitySolid = 2719.0;
double cpSolid = 871.0;
double kSolid = 202.4;

#************************************************************************
#                           File In or Out                              *
#************************************************************************
// numberOfGridGroups: The number of grid groups.
// gridfile: The partitioned Grid file path, using relative path,
//           which is relative to the working directory.
// IMPORTANT WARNING: The file index should be ignored,
//                    e.g. if the partitioned grid is rae2822_hybrid2d__4_0.fts,
//                    please use 'rae2822_hybrid2d__4.fts' here!
// plotFieldType: If dump out the field results to visulization.
// walldistMethod: The method to compute wall distance.
//                 0 -- accurate but not fast enough.
//                 1 -- fast but not accurate enough.
//                 2 -- super fast but more non-accurate!
// resSaveFile: The file path to save the residual convergence process, write data for every default (intervalStepRes) steps.
// turbresfile: The file path to save the residual convergence process of turbulence, write data for every default (intervalStepRes) steps.
// aircoeffile: The file path to save the aerodynamic force coefficients convergence process, write data for every default (intervalStepForce) steps.
// restartNSFile: The file path to write restart flowfield variables, write data for every default (intervalStepFlow) steps.
// turbfile: The file path to write restart flowfield variables of turbulence , write data for every default(intervalStepFlow) steps.
// visualfile: The visualization file path of flowfield, write data for every default (intervalStepPlot) steps.
// wall_aircoefile: The file path to save flowfield variables of wall, write data for every default steps.
// nDumpSurfaceInfo = 0 the "wall_varfile" write the informations including heat flux.
// nDumpSurfaceInfo = 1 the "wall_varfile" write the informations without heat flux.
// nIsComputeWallDist: Whether to compute the wall distance.  
//                     0 -- Compute wall distance.
//                     1 -- Not compute.
// protectionFile0 and protectionFile1: Two continuation file of the data protection mechanism.
// wall_heatfluxfile: The file to output the MaxHeatFlux of wall.
// isRestartChangeInflow: Whether to change the inflow conditions for continued calculation.

int    numberOfGridGroups  = 1;
string gridfile            = "./grid/rae2822_hybrid2d__4.fts";
string wallTemperaturefile = "";

int    nIsComputeWallDist = 0;
int    walldistMethod     = 1;
int    cellMethodOrNodeMethod = 0;

int    isRestartChangeInflow = 0;

string resSaveFile        = "results/res.dat";
string turbresfile        = "results/turbres.dat";
string transitionResFile  = "results/transitionRes.dat";
string aircoeffile        = "results/aircoef.dat";

string restartNSFile      = "results/flow.dat";
string turbfile           = "results/turb.dat";
string transitionFile     = "results/transition.dat";

string visualfile         = "results/tecflow.plt";
string wall_aircoefile    = "results/wall_aircoef.dat";
string samplefile         = "results/sample.dat";

string protectionFile0    = "results/flow0.dat";
string protectionFile1    = "results/flow1.dat";
string wall_heatfluxfile  = "results/wall_heatflux.dat";

string protectionTurbFile0 = "results/turb0.dat";
string protectionTurbFile1 = "results/turb1.dat";

string protectionTransitionFile0 = "results/transition0.dat";
string protectionTransitionFile1 = "results/transition1.dat";

int    nDumpSurfaceInfo   = 0;
string wall_varfile       = "";

string sixDofFileName     = "results/sixDofInfo.dat";
string derivativeFileName = "results/identify.dat";
string hysteresisFileName = "results/force_beta.plt";

string restartGridFile     = "results/rae2822_hybrid2d__4.fts";
string restartNSVarFile       = "results/flow.dat";
string restartTurbVarFile     = "results/turb.dat";

int plotFieldType = 0;
int dumpFlowOnOriginalGrid = 0;

// visualfileType: The file type of visualfile.
//                 0 -- Tecplot binary.
//                 1 -- Tecplot ASCII.
//                 2 -- Ensight binary.
//                 3 -- Ensight ASCII.
//                 4 -- Paraview.
int visualfileType = 1;

// samplefileMode: The dump mode of sample file.
//                 0 -- dump out every probe/line/surface data for all step intervals.
//                 1 -- dump out all probe/line/surface data for every step intervals.
int samplefileMode = 0;

// visualSlice: The slice of tecflow.
//              0 -- Do not save slice data.
//              1 -- comput and save it to sliceFile.
// sliceAxis: Normal vector of slice.
//            1 -- X_DIR.
//            2 -- Y_DIR.
//            3 -- Z_DIR.
// slicePostion: Coordinate of slice.

int    visualSlice  = 0;
int    sliceAxis    = 1;
double slicePostion = -0.5;
string sliceFile    = "results/Slice.plt";
int    dumpWallFaceCenter = 0;

// min-max box of the visual block.
double lowerPlotFieldBox[] = [0.0 0.0 0.0];
double upperPlotFieldBox[] = [1.0 1.0 1.0];

//-----------the optional parameters list for the flow field output----------------
// nVisualVariables: Number of variables want to be dumped for tecplot visualization.
// visualVariables : Variable types dumped, listed as following:
//                   -- density(0), u(1), v(2), w(3), pressure(4), temperature(5), mach(6),
//                   -- viscosityLaminar(7), viscosityTurbulent(8), 
//                   -- vorticity_x(9), vorticity_y(10), vorticity_z(11), vorticityMagnitude(12),
//                   -- strain_rate(13), Q_criteria(14), Cp(15), timeStep(16), volume(17),
//                   -- modeledTKE(18), modeleddissipationrate(19), SSTF1(20), SSTF2(21), 
//                   -- vibration temperature(Tv, 33), electron temperature(Te, 34), vibrational energy(Ev, 35), electric energy(Ee, 36),
//                   -- number density of electron(Ne, 37), dimensioanl density(rho, 38), dimensioanl pressure(p, 39), dimensioanl temperature(T, 40),
//                   -- gradientUx(41), gradientUy(42), gradientVx(43), gradientVy(44), streamline_u(45), streamline_v(46), streamline_w(47),
//                   -- transition intermittency(intermittency, 51), transition momentum thickness reynolds(MomentumThicknessReynolds, 52),
//                   -- local CFL Number(localCFL, 57), minimal CFL Number(minCFL, 58)(the two parameters are related to CFL self-adaptive, only support struct grid)
//                   -- overlap iblank(iblank, 81),
//                   -- specific heat ratio(gama, 56), Knudsen number(kn, 60), Damkohler number(Da, 61), vibrational nonequilibrium number(Vi, 62).
// Important Warning: Array size of visualVariables MUST be equal to nVisualVariables!!!
// Variables order must from small to big.
//-----------the optional parameters list for the wall boundary condition----------------
// nVisualWallVariables: The number of visual variables on wall.
// visualWallVariables : dumped variable types, listed as following:
//                   -- coefficient of pressure(cp, 0), coefficient of friction(cf, 1), yplus(2), non-dimensional heat flux(Q_NonDim, 3), dimensional heat flux(Q_Dim, 4),
//                   -- pressure on wall(pw, 5), temperature on wall(Tw, 6), density on wall(rhow, 7), heat flux of translational-rotational temperature term(Qtr, 8),
//                   -- heat flux of species diffusion term(Qs, 9), heat flux of vibrational temperature term(Qv, 10), heat flux of electron temperature term(Qe, 11),
//                   -- species mass fractions(Ns, 12), x component of wall velocity(Vx, 13), y component of wall velocity(Vy, 14), z component of wall velocity(Vz, 15),
//                   -- slip translational-rotational temperature(Tts, 16), slip vibrational temperature(Tvs, 17), slip electron temperature(Tes, 18), absolute wall velocity(Vs, 19),
//                   -- Stanton number(St, 20), coefficient of heat rate(Ch, 21), temperature jump(deltaT, 22), Grid Reynolds number on wall(Re_w, 23), Knudsen number(Kn_wall, 24).
int nVisualVariables = 8;
int visualVariables[] = [0, 1, 2, 3, 4, 5, 6, 15];

int nVisualWallVariables = 6;
int visualWallVariables[] = [0, 1, 2, 3, 4, 5];

// dumpStandardModel: Dump many standard model data.
//                    1 -- Turbulent flat plate.
int dumpStandardModel = 0;

// ifSetDataMonitor: Whether to set the data monitor.
//                   0 -- No.
//                   1 -- Yes.
// dataMonitorType: The type of data Monitor.
//                  0 -- Probes data monitor.
//                  1 -- Lines data monitor.
//                  2 -- Surfaces data monitor.
// probesDefineFile: Probes location information file.
// nLines: The number of lines need to be monitored.
// linesDefineFile: Lines location information file.
// nSurfaces: The number of surfaces need to be monitored.
// surfacesDefineFile: Surfaces location information file.
// searchCellsMethod: method to search the cell of each probe.
//                    0 -- Nearest cell to the probe.
//                    1 -- Real cell where the probe is located.
// nProbeVariables: Number of variables want to be dumped for probes monitered.
// probeVariables : Variable types dumped, listed as following:
//                  -- density(0), u(1), v(2), w(3), pressure(4), temperature(5), mach(6),
//                  -- dimensioanl_density(7), dimensioanl_u(8), dimensioanl_v(9), 
//                  -- dimensioanl_w(10), dimensioanl_pressure(11), dimensioanl_temperature(12).
// Important Warning: Array size of probeVariables MUST be equal to nProbeVariables!!!
// probeVariables order must from small to big.
// probeVariablesInterpolationMethod: Interpolation method used to compute the probe variables.
//                  0 -- Take the value of probe's cell as probe real value.
//                  1 -- Interpolation from probe's and neighbouring cell to probe.
//                  2 -- Interpolation from probe's cell nodes to probe.
int ifSetDataMonitor = 0;

int    dataMonitorType  = 0;
string probesDefineFile = "bin/probes_XYZ.dat";

//int    dataMonitorType = 1;
//int    nLines = 1;
//string linesDefineFile = "bin/lines_XYZ.dat";

//int    dataMonitorType = 2;
//int    nSurfaces = 4;
//string surfacesDefineFile = "bin/surfaces_XYZ.dat";

int searchCellsMethod = 0;

int nProbeVariables  = 14;
int probeVariables[] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13];
int probeVariablesInterpolationMethod = 0;

#************************************************************************
#                           Turbulence Parameter                        *
#************************************************************************
// turbInterval: Iteration number of turbulence.
// kindOfTurbSource: Kinds of turbulent source.
//                   0 -- Original.
// mod_turb_res: If modify the residuals for the cells next to the wall or not, default is 0.
// transitionType: transition model type
//                   0 -- none.
//                   2 -- gama-re-theta.
// turbIntensity: (valid while greater than 0.0 ) turbulent intensity of free stream(*100) in transition.
// freeturbIntensitySRModify: to use SR modify in free stream turbulent intensity decay or not.
// qTurbLimit: If limit the min/max qTurb for the SA model or not, default is 0.

int turbInterval     = 1;
int turbOrderStruct  = 2;
int kindOfTurbSource = 0;
int mod_turb_res     = 0;
double freeStreamViscosity = 1.0e-3;
double muoo          = 3.0;
double kwoo          = 5.0;
int transitionType   = 0;
double turbIntensity = -1.0;
int freeturbIntensitySRModify = 0;
double freeDecayXLocation = 0.0;
int compressibleCorrection = 0;
int transitionMaFix = 1;
int qTurbLimit      = 0;
// maximum eddy viscosity (myt/my) max.
double eddyViscosityLimit = 1.0e10;
int monitor_vistmax = 0;

#************************************************************************
#                           LES Parameter                               *
#************************************************************************
// iLES: Create LESSolver or not.
//       = 1 -- Create LESSolver;
//      != 1 -- not.
// amplitudeofDisturb: Amplitude of adding disturb.
// disturbstep: Unsteady time step or steady iteration of adding random disturb.
// iterdisturb: Add random disturb in every sub-iter or only first sub-iter.
//              = 0 -- in only first sub-iter;
//             != 0 -- in every sub-iter.
// ipraddisturb: Add density and pressure disturb or not.
// ibodyforce: Add body force in source flux of NS equations or not.
//             = 0 -- not;
//            != 0 -- Add body force.
// bodyforce: Body force in source flux of NS equations or not.
// utau: friction velocity, using in DNSDisturb.
// sgsmodel: subgrid scale model.
//           = "smagorinsky";
//           = "dsmCom";
//           = "wale";
//           = "sigma".
// deltaFunctionType: = 1 -- MAX(deltai, deltaj, deltak);
//                    = 2 -- pow(deltai * deltaj *deltak, 1/3);
//                    = 3 -- Devloped by Scotti.
// wallDampingFunctionType: = 0 -- no wall function;
//                          = 1 -- van Driest;
//                          = 2 -- developed by Dr. Deng Xiaobing;
//                          = 3 -- developed by Piomelli.
// turbViscousCutType: turbulent viscosity cut type.
//                     = 0 -- mu_total = mut             + mul;
//                     = 1 -- mu_total = max(mut-mul, 0) + mul;
//                     = 2 -- mu_total = max(mut    , 0) + mul.
// smagConstant: constant of smagorinsky model.
// waleConstant: constant of wale model.
// filterDirection [3]: filter variables in i, j, k direction or not.
// averageDirection[3]: average variables in i, j, k direction or not.
// isotropicConstant: constant of isotropic part of SGS stress.
int    iLES               = 0;
string sgsmodel           = "smagorinsky";
int    deltaFunctionType  = 2;
int    wallDampingFunctionType = 1;
int    turbViscousCutType = 2;
double smagConstant       = 0.1;
double isotropicConstant  = 0.0;
double waleConstant       = 0.6;
double sigmaConstant      = 1.35;
int    filterDirection[]  = [1, 1, 0];
int    averageDirection[] = [0, 0, 0];
double testFilterScale    = 2.0;
int    averageWidth       = 1;
int    monitorNegativeConstant = 0;

#************************************************************************
#          Other Parameters for Hypersonic Non-equilibrium Gas          *
#************************************************************************
// dg_high_order:
//               0 -- generic order accuracy.
//               1 -- high order accuracy.
// iapplication:
//               0 -- gas model is fixed in the codes.
//               1 -- gas model is imported from library files.
// isAdaptiveSolver: isAdaptiveSolver = 0 indicates the generic Navier-Stokes solver.
// nm: Equation number of the physics, but is out of commision now.
//               4 -- for 2D.
//               5 -- for 3D.
// nGasModel: The type of gas. less than and equal to 1 represents the mixture gas. 
//            Otherwise, the pure gas with one component is used for perfect gas.
//               0 -- Earth gas.
//               1 -- Mars gas.
//               2 -- Argon.
//               3 -- Nitrogen.
// nEnergyRecycle: The type of EnergyModel Recycle. 
//               0 -- not used.
//               1 -- used.
// nDensityModify: The type of densitymodify. 
//               0 -- not used.
//               1 -- used.
// nchem:
//               0 -- without chemical reaction flow.
//               1 -- the chemical reaction flow is considered.
// nEquilibriumGas: the variable is valid when the condition of nchem = 0 is satisfied.
//               0 -- perfect gas.
//               5, 7, 11 -- equilibrium gas, meanwhile, its value denotes the number of gas component.
// nPCWCycleStep: The maximum step number of iteration in the module of computing species mass fractions with the partial catalytic wall(PCW) condition.
//                The value equals to or is greater than 1, and 3 is for default value.
// nRETCycleStep: The maximum step number of iteration in the module of computing radiation equilibrium temperature on wall.
//                The value equals to or is greater than 1, and 3 is for default value.
// nSLIPCycleStep:The maximum step number of iteration in the module of computing slip temperature, slip velocity and slip species mass fraction.
//                The value equals to or is greater than 1, and 3 is for default value.
// nSlipBCModel:  The computational model of slip boundary conditions.
//               0 -- no slip.
//               1 -- the conventional Maxwell slip conditions.
//               2 -- the Gokcen slip conditions. 
//               3 -- the Knudsen-layer correction of the standard slip conditions proposed by Lockerby, et al.
//               4 -- the Kogan simplified slip conditions.
// nMeanFreePathType: the method to the mean free-path for the slip conditions. For the mixture, 0 is suggested.
//               0 -- the equivalent mean free-path is calculated by the simple hard sphere model(HS).
//               1 -- calculated by the definition that includes the variables of the number density and the molecule diameter.
//               2 -- the equivalent mean free-path is calculated by the variable hard sphere model(VHS).
// nchemsrc:
//               0 -- the source terms are not computed.
//               1 -- the source terms are computed.
// nchemrad:
//               0 -- compute the spectrum radius without considering chemical reaction flow.
//               1 -- compute the spectrum radius that need to count the contribution from chemical reaction flow.
// ntmodel: The thermodynamic temperature model.
//               1 -- One-temperature model.
//               2 -- Two-temperature model.
//               3 -- Three-temperature model.
// isUseNoneqCond:
//               0 -- compute the source terms without any conditions.
//               1 -- compute the source terms using the non-equilibrium condition.
// frozenCondition: the threshold value of frozen chemical flow condition, 0.1 is the default value.
// nIdealState: whether take all gas species as ideal gas for gas-mixture process.
//               0 -- No.
//               1 -- Yes. 
// nTEnergyModel: the method to computing temperature energy model.
//               0 -- the energy term is computed using the conventional method.
//               1 -- the energy term is computed using the polynomial fitting method.
//               2 -- the energy term is computed using the piecewise polynomial fitting method.
// parkVDPower: the power of translational-rotational temperature in the Park V-D(vibration-dissociation) coupling model.
//              The value is in range of [0.0, 1.0], DPLR suggests 0.5, LAURA suggests 0.7, while 0.6 is given as default value.
// catalyticCoef:
//              0.0 -- full non-catalytic wall boundary condition.
//              1.0 -- full catalytic wall boundary condition.
//              in range of (0.0, 1.0) -- partial catalytic condition, the value indicates the catalytic coefficient.
// nIsSuperCatalytic: the super catalytic condition for the fully catalytic wall, and assigned with the value of 1.
//              0 -- equilibrium condition for the fully catalytic wall where the mass fractions are assigned with the values of the free stream.
//              1 -- super catalytic condition for the fully catalytic wall where all the atomic components combine into molecular components.
// nTemperatureJump: the method to calculate the temperature jump.
//              0 -- calculated by the variables of heat conductivity and constant volume specific heat for each energy mode.
//              1 -- the general method where the iteration is calculated with the translation-rotation temperature.
// nSurfGradMethod: the method to compute the surface heating ratio.
//              0 -- the gradient of variable is computed with the first-order difference method.
//              1 -- the gradient of variable is computed with the Green-Guass integral method.
// nRapidFlowfield: initialize the flowfield using the rapid engineering method when it is greater than zero.
// nSurfHeatMonitor: To exam the surface heating change or not. 0 is no, 1 is yes.
// nInitPressureStep: the steps to initialize the boundary variables when the rapid method is used. 100 is the default value.
// nDumpCFLNumber: 1 indicates dumping the CFL number to file, 0 denotes no dumping.
// sigmaVelocity: the coordination coefficient of tangential momentum for computation of slip velocity. The value is in range of (0.0, 2.0].
// sigmaTemperature: the heat coordination coefficient for computation of slip temperature. The value is in range of (0.0, 2.0].
// sigmaMassFraction: the species coordination coefficient for computation of slip mass fractions. The value is in range of (0.0, 2.0].
// velocitySlipCorrectConstant: the correction constant to the velocity slip condition. For the diffuse reflection, 1.0 is used.
//              1.0 -- proposed by Maxwell.
//              sqrt(2/PI)~0.8 -- used for "micro-slip", namely the actual velocity slip at the wall.
//              1.146 -- proposed for an additional "fictitious" velocity slip.
// chemicalRelaxCorf:       The value is in range of [0.001, 1.0].
// spectrumRadiusCoef: 	    The value is in range of [0.0, 2.0].
// staticPressureRelaxCorf: The value is in range of [0.1, 1.0].
// nIsChemicalFreeze: the flag to freeze the chemical reactions.
//              0 -- not freeze, the chemical reaction sources will be calculated.
//              1 -- freezes the chemical reactions, the chemical reaction sources will not be calculated. 
// veTemperatureMin: The minimum of Tv and Te.
// maxViscous: the maximum of Viscous.
// trTemperatureMin: the minimum value of trTemperature.
// veTemperatureMin: the minimum value of veTemperature.
// densityMin: the minimum value of density.
// tAdjustmentFactor: magnification of temperature, this value is in range of (1.0, 10.0].
// nDebug: cout the Wrong place and abort
//              0 -- not used.
//              1 -- used.
// nSpeciesLimit: limitter of gas species
//              0 -- not used.
//              1 -- used.
// nTurblenceForChemical: the coupled mode of Turblence and Chemical reaction.
//              0 -- method 0.
//              1 -- method 1.
// nViscosityFluxSublevelModified: Modified for ViscosityFlux on Sublevel grid.
//              0 -- not used.
//              1 -- used.
// nViscosityPeModified: Pe Modified for ViscosityCoef.
//              0 -- not used.
//              1 -- used.
// nChemcalSourceModified: Modified on ChemcalSource.
//              0 -- not used.
//              1 -- used.
// nChemcalSourceEsMethod: Modified on ChemcalSource.
//              0 -- approximation algorithm 1 (Ori).
//              1 -- approximation algorithm 2 (New).
// nMaxStepTemperature: the iterative steps of temperature.
// veTemperatureMinModified: Modified on the minimum of Tve for Cvvs.
//              0 -- not used.
//              1 -- used.
// nDiagonalModified: Modified on Diagonal.
//              0 -- not used.
//              1 -- new.
// nDiagonalModifiedTurb: Modified on Diagonal for turbulence.
//              0 -- not used.
//              1 -- new.
// nGradPrimtiveMethod: 
//              0 -- Ori.
//              1 -- new.
// nAblation:
//              0 -- The wall ablation is not computed.
//              1 -- The wall ablation is computed.
// isInjection:
//              0 -- The injection velocity of ablation wall is not computed.
//              1 -- The injection velocity of ablation wall is computed.
// nViscosityModel:
//              0 -- Blottner fitting method(N89).
//              1 -- Gupta fitting method(N90).
// nContinueModel: The new continue model can switch different computation model.
//              0 -- Not use the new continue model.
//              1 -- use the new continue model.
// nSutherland:
//              0 -- stands for selecting the Blotter curve fits mode.
//              1 -- stands for Sutherland relation.
// gasfile: Indicates the gas model, 9 models are provided, namely "Gu5", "Gu7", "Gu11", "Pa5", "Pa7", "Pa11", "DK5", "DK7", "DK11".
//              "Gu" -- indicates the Gupta Model, three-Type Models are embeded in the library, namely, the 5-species-6-reactions, the 7-species-9-reactions, the 11-species-20-reactions.
//              "Pa" -- indicates the Park  Model, three-Type Models are embeded in the library, namely, the 5-species-17-reactions, the 7-species-22-reactions, the 11-species-48-reactions.
//              "DK" -- indicates the Dunn-Kang Model, three-Type Models are embeded in the library, namely, the 5-species-11-reactions, the 7-species-15-reactions, the 11-species-26-reactions.
//              "Mars-Pa8" is for Park model of Mars gas, "Mars-Mc8" for McKenzie model of Mars gas.
//              "Combustion-12" -- indicates the Combustion Chamber Gas Model which includes 12-species-20-reactions.
//              "Gas-Mixture" -- indicates the process of mixing gas without reacting.
//                               for struct solver mixing two species "SpeciesA, SpeciesB".
//                               for unstruct solver mixing multi-species "O2 NO CO CO2 H2 N2 Air CH4".
//              For self-definition model, the gasfile is used to indicate the file path of the new gas model.
// speciesName: Used to list the names of each species, while each species name is separated by the symbol of comma.
// initMassFraction: Used to list the initial mass fractions of species in accordance with the sequence of names in the parameter speciesName.
// ifStartFromPerfectGasResults: The chemical reaction simulation is start from perfect gas flowfield or not, 0 is for no and else is for yes.
// nIterFirstStep : the maximum number of iteration in the first step for the self-adaptive calculation.
// nIterSecondStep: the maximum number of iteration in the second step for the self-adaptive calculation.
// nIterThirdStep : the maximum number of iteration in the third step for the self-adaptive calculation.
// nEnergyAssembly: the vibration energy is computed with combined method which includes the fitting method and the molecular kinetic theory.
//                  0 -- no, 
//                  1 -- yes.
// nControlVariable: the variable to computing the residual error that determines the convergence is meet or not in the one-temperature model.
//                  0 -- the density.
//                  1 -- the translation temperature.
//                  2 -- the vibration temperature.
//                  3 -- the electron temperature.
//                  4 -- the pressure.
//                  5 -- the mass fraction of oxygen.
//                  6 -- the mass fraction of nitrogen.
// firstStepError  : the residual error of the first step iteration for the self-adaptive calculation.
// secondStepError : the residual error of the second step iteration for the self-adaptive calculation.
// thirdStepError  : the residual error of the third step iteration for the self-adaptive calculation.
//  nProtectData: Use the continuation file data protection mechanism.
//                  0 -- no.
//                  1 -- yes.
//  nTvChange: Judge whether the Tv equals Ttr.
//                  0 -- yes.
//                  1 -- no.
// isMoleFractionType: 1 indicates the mass fractions, or else the mole fractions.
// nFraction: the initial fractions type of species. 
//            0 -- mass fraction.
//            1 -- mole fraction.
int dg_high_order = 0;
int iapplication  = 0;
int isAdaptiveSolver = 0;
int nm = 5;
int nEquilibriumGas = 0;
int nPCWCycleStep  = 3;
int nRETCycleStep  = 3;
int nSLIPCycleStep = 3;
int nIterFirstStep = 1000;
int nIterSecondStep= 2000;
int nIterThirdStep = 2000;
int nEnergyAssembly = 0;
int nControlVariable = 1;
double firstStepError  = 0.01;
double secondStepError = 0.001;
double thirdStepError  = 0.001;
double predictCFLError = 0.1;

double refGama = 1.4;
double prl     = 0.72;
double prt     = 0.90;
double sc_l    = 0.5;
double sc_t    = 0.5;

int nGasModel  = 0;
int nchem      = 0;
int nchemsrc   = 1;
int nchemrad   = 1;
int ntmodel    = 1;

int nIdealState = 0;
int nEnergyRecycle = 1;
int nSlipBCModel   = 0;
int nDensityModify = 1;
int nTEnergyModel  = 0;
int nMeanFreePathType = 0;
int nIsChemicalFreeze = 0;
int nIsSuperCatalytic = 1;
int nTemperatureJump  = 0;
int nSurfGradMethod = 0;
int nRapidFlowfield = 0;
int nSurfHeatMonitor = 0;
int nInitPressureStep = 100;
int nDumpCFLNumber = 0;

double parkVDPower   = 0.6;
double catalyticCoef = 0.0;
double sigmaVelocity = 1.0;
double sigmaTemperature = 1.0;
double sigmaMassFraction = 1.0;
double velocitySlipCorrectConstant = 1.0;

double chemicalRelaxCorf = 1.0;
double chemicalSpectrumRadiusCoef = 1.0;
double viscousSpectrumRadiusCoef  = 1.5;
double inviscidSpectrumRadiusCoef = 1.5;
double spectrumRadiusCoef = 0.5;
double staticPressureRelaxCorf = 0.2;

double maxViscous = 10000.0;
double trTemperatureMin = 10.0;
double veTemperatureMin = 30.0;
double maxTemperature = 50000.0;
double densityMin = 1.0e-8;
double densityMinFactor = 0.1;
double tAdjustmentFactor = 10.0;
double iniSpeedCoef = 1.0;
int iniSpeedMode = 0;

int nDebug = 0;
int nSpeciesLimit = 1;
int nTurblenceForChemical = 0;
int nViscosityFluxSublevelModified = 1;
int nViscosityPeModified = 0;
int nChemcalSourceModified = 2;
int nChemcalSourceEsMethod = 1;
int nMaxStepTemperature = 5;
int veTemperatureMinModified = 1;
int nDiagonalModified = 0;
int nDiagonalModifiedTurb = 0;
int nGradPrimtiveMethod = 1;
int nInviscidFluxModify = 1;
int nQlLimitMethod = 2;
int nSpeciesForWallMethod = 1;
int nDensityForWallMethod = 0;
int wallMultiTemperature = 0;

int nProtectData = 0;
int nAblation = 0;
int isInjection = 0;
int nViscosityModel = 0;
int nMarsModel = 0;
int nTvChange = 0;
int isMoleFractionType = 0;
string gasfile = "DK5";
//string gasfile = "./chemical/Dunn-Kang_air5s11r.dat";
string speciesName = "O, O2, NO, N, N2";
string initMassFraction = "0.0, 0.233, 0.0, 0.0, 0.767";

//string speciesName = "O, O2, NO, N, NO+, N2, e-";
//string initMassFraction = "0.0, 0.233, 0.0, 0.0, 0.0, 0.767, 0.0";

//string speciesName = "O, O2, NO, N, O+, O2+, NO+, N+, N2+, N2, e-";
//string initMassFraction = "0.0, 0.233, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.767, 0.0";

//string gasfile = "Mars-Pa8";
//string speciesName = "O, O2, NO, N, N2, C, CO, CO2";
//string initMassFraction = "0.0015, 0.0429, 0.0, 0.0, 0.0, 0.0, 0.0777, 0.8779";

//string gasfile = "Pa";
//string speciesName = "O, O2, NO, N, NO+, C, C2, CO, CO2, CN, N2, e-";
//string initMassFraction = "0.0, 0.233, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.767, 0.0";

//string gasfile = "Combustion-12";
//string speciesName = "O, O2, NO, N, C, CO, CO2, H, H2, OH, H2O, N2";
//string initMassFraction = "0.0, 0.233, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.767";
 
//string gasfile = "Gas-Mixture";
//string speciesName = "SpeciesA, SpeciesB";
//string initMassFraction = "1.0, 0.0";
int    nSutherland  = 0;
double gamaSpeciesA = 1.4;
double gamaSpeciesB = 1.3;
double molecularWeightSpeciesA = 29.0;
double molecularWeightSpeciesB = 30.0;

//string gasfile = "Gas-Mixture";
//string speciesName = "O2, N2";
//string initMassFraction = "1.0, 0.0";

int nFraction = 0;
int nContinueModel = 0;
int ifStartFromPerfectGasResults = 0;
int isUseNoneqCond = 0;
double frozenCondition = 0.01;

int nLeakageMonitor = 0;
double totalLeakageVolume = 1000.0;
double monitorThresholdValue = 0.05;
double sprayFactor = 0.0;

#########################################################################
// Multi-Grid parameters.
// nMGLevel: The number of level of Multi-Grid.
//           <= 1 -- Single-level.
//           >  1 -- multi-level.
// MGPreIteration: For each grid, the number of pre-smoothing steps.
// n_post: For each grid, the number of post-smoothing steps.
// MGCoarsestIteration: For the coarest grid the number of smoothing steps.
// MGFasType: V-multi cycle or W-multi cycle.
//            1 -- V-multi cycle.
//            2 -- W-multi cycle.
// flowInitStep: Flow initialization step, 0 - 500 is suggested.
//               Multi-Grid : Number of steps computing on coarse grid, during flow initialization.
//               Single-Grid: Number of steps computing using first-order with vanleer, during flow initialization.
// mgCFLScale: CFL number enlarge times for coarse grid.
// mprol: Multi-grid interpolation method, interpolation from coarse cell to fine grid.
//        1 -- zero order.
//        2 -- first-order. (default)
// mgCorrectionLimit: Multi-grid correction limit.
int nMGLevel = 1;
int MGCoarsestIteration = 1;
int MGPreIteration = 1;
int MGFasType = 1;
int n_post = 0;
int flowInitStep = 100;
int mprol = 2;
double mgCFLScale = 1.0;
double mgCorrectionLimit = 0.01;

//--------------- Some parameter for turbulent model --------------------
// neasm: The variation of kw turbulent model.
// ismooth_turb: Residual smooth for turb or not.
// SSTProductType: The type of product term based on vorticity for SST.
// SAProductType: The type of product term based on vorticity for SA.
int neasm = -3;
int SSTProductType = 0;
int ismooth_turb = 0;
int SAProductType = 2;

// ----------------- Overset Grid parameter -----------------------------
int codeOfDigHoles       = 1;
int codeOfTurbulentModel = 0;
string masterFileName      = "./grid/searchFile.inp";
string holeBasicFileName   = "./grid/holeBasicFile.inp";
string holeFullFileName    = "./grid/holeFullFile.dat";
string linkFileName        = "./grid/topology.dat";
string zoneInverseFileName = "./grid/zoneInverseMapping.inp";

#************************************************************************
#                       High Order Struct Solver                        *
#************************************************************************
// isFVMOrFDM:
//             0 -- NSSolverStruct using Finite Volume Method.
//             1 -- NSSolverStruct using Finite Differ Method.
// SolverStructOrder: Spatial discretisation order of NS equations with struct grid.
//                    <= 2 -- finite volume method.
//                    >= 3 -- finite difference order. (to be completed)
//                       0 -- default.
// str_highorder_interpolation_epsilon: Epsilon in weighted interpolation, bigger epsilon, better convergence,
//                                      smaller epsilon, robuster for shock-detecting.
// str_highorder_interpolation_type:
//                    -- "classical", "test".
// str_highorder_flux_name:
//                    -- "roe", "steger".
// structhighordergradient:
//                    -- "conservation", "chain_rule".
int    isFVMOrFDM                          = 0;
string str_highorder_solver                = "WCNS";
int    SolverStructOrder                   = 0;
double str_highorder_interpolation_epsilon = 1.0e-6;
string str_highorder_interpolation_type    = "test";
string str_highorder_flux_name             = "steger";
string structhighordergradient             = "conservation";
double coefofstrflux        = 0.5;
double limitcoefofinterface = 0.0;

// ----------------- Advanced choices -----------------------------------
// outtimesc: Time stepping scheme for the outer loop.
// MUSCLCoefXk: The parameter of MUSCL interpolations, belongs to [-1, 1].
//             -1 -- seconde-order fully-upwind differencing.
//              0 -- seconde-order upwind-biased differencing.
//       0.333333 -- third-order upwind-biased differencing.
//              1 -- seconde-order central differencing.
// MUSCLCoefXb: The limiter parameter.
//              0 -- the effect of the limiter is cancelled, means the first-order interpolations.
// allReduceStep: Iteration intervals for MPI AllReduce operation, default is 1.
string outtimesc   = "impbd2";
double MUSCLCoefXk = -1;
double MUSCLCoefXb = 1.0;
int  allReduceStep = 1;

// ----------------- overlap configuration ------------------------------
// codeOfOversetGrid: Overlapping(overset) grid or not.
//             0 -- NON-overlapping grid.
//             1 -- Overlapping grid.
// oversetInterpolationMethod: the method of overset interpolation while field simulation.
//             0 -- set the acceptor cell value by donor cell value.
//             1 -- set the acceptor cell value by distance weight of donor cell value.
// readOversetFileOrNo: Whether to read overset-file(.ovs) that has been generated.
//             0 -- no.
//             1 -- yes.
// symetryOrNot: If there exist symetryplanes(XY plane, the coordinate of Z direction is 0) in 
//               the current overset grid(only for three dimension).
//             0 -- no.
//             1 -- yes.
// readInAuxiliaryInnerGrid: Whether to read auxiliary inner grid.
//             0 -- no.
//             1 -- yes.
// walldistMainZone: The initial value of background grid which does not exist wall boundary condition.
// toleranceForOversetSearch: The tolerance of overset searching zone to judge whether the obtained node is in the current computing cell.
// toleranceForOversetBox: The tolerance of building the minimum box of computing cells in the overlapping region.
// nLayerOfInterCells    ：The number of interpolated cell layers in the overlapping boundary for Explicit assembly. 
//             0 -- one layer.
//             1 -- two layers or more.
// keyEnlargeOfInterBoundary: The range of interpolation boundary conditions.
// keyEnlargeOfBufferNodes: The number of enlarged overset-boundary layers in the buffer region.
// outTecplotOverset: Whether to dump out the flowfield data after the progress of overset configure.
//             0 -- no.
//             1 -- yes.
int    codeOfOversetGrid          = 0;
int    isOversetSlip              = 0;
int    isCommGradientforSlip      = 0;
int    oversetGridConfigMethod    = 1;
int    oversetInterpolationMethod = 0;
int    readOversetFileOrNot       = 0;
int    symetryOrNot               = 0;
int    readInAuxiliaryInnerGrid   = 0;
int    readInAuxiliaryOuterGrid   = 0;
int    readInSklFileOrNot         = 0;
string auxiliaryInnerGrid0        = "./grid/aux-upper.fts";
string auxiliaryInnerGrid1        = "./grid/aux-lower.fts";
string auxiliaryInnerGrid2        = "";
string oversetGridFileName        = "./grid/iblank.ovs";
double defaultBlockWalldist_0     = 1.0
double defaultBlockWalldist_1     = 1.0
double defaultBlockWalldist_2     = 1.0
double toleranceForOversetSearch  = 1.0e-3;
double toleranceForOversetBox     = 1.0e-3;
int    keyEnlargeOfInterBoundary  = 0;
int    keyEnlargeOfBufferNodes    = 0;
int    keyEnlargeOfSearchNodes    = 2;
int    nLayerOfInterCells         = 0;
int    nCommunicateCellIBlank     = 0;
int    outTecplotOverset          = 0;
int    outPutOversetVisualization = 0;
int    numberOfMovingBodies       = 2;
int    nLayerOfCellsOfCutting     = 0;
int    ifCheckWallCollision       = 1;
// ----------------- ALE configuration ------------------------------
int codeOfAleModel                = 0;
int aleStartStrategy              = -1;

double referenceLength            = 1.0;
double referenceVelocity          = 1.0;
double referenceDensity           = 1.0;

int strategyForFaceNormalVelocity = 0; // 0-By Sweeping volume; 1-By face center 1st; 2-By face center 2nd.
int strategyForGCLSource          = 0; // 0-present; 1-Ahn.

// 0: 1st-Admas-Bashforth; 1: 2nd-Admas-Bashforth; 2: 1st-Implicit-Euler; 3: 2nd-Implicit Euler; 4: 2nd-Adams-Moulton; 5: 3rd-Adams-Moulton.
int    methodForKineticEquation   = 0;
double relaxParameterOfKinetic    = 1.0;

#************************************************************************
#                           motive information                          *
#************************************************************************
int    numberOfMovingBodies = 1;

##############################    body0    ##############################
// mass of parts.
double mass_0 = 1.0;
// gravity of parts (along negative direction in Y-axis, eg. 9.8).
double gravity_0 = 0.0;
// mass matrix of parts Ixx   Iyy   Izz   Ixy  Ixz  Iyz.
double massMatrix_0[] = 1e-7, 1e-6, 1e-6, 0.0, 0.0, 0.0;
// initial six DOF position information of parts. xc yc zc.
double massCenter_0[] = 0.0, 0.0, 0.0;
// if reset mass center while restart.
int resetMassCenter_0 = 0;
// position offset of parts. dx dy dz.
double massCenterDxyz_0[] = 0.0, 0.0, 0.0;
// initial six DOF position information of parts. angleX angleY angleZ.
double attitudeAngle_0[] = 0.0, 0.0, 0.0;
// initial six DOF move information of parts. vc vy vz.
double massCenterVelocity_0[] = 0.0, 0.0, 0.0;
// initial six DOF move information of parts. omigX omigY omigZ.
double angularVelocity_0[] = 0.0, 0.0, 0.0;
// the object that the parts belong to.
int fartherIndex_0 = -1;
// the assembly position of the parts. xc yc zc angleX angleY angleZ.
double configPamameter_0[] = 0.0, 0.0, 0.0, 0.0, 0.0, 0.0;
// the move pattern of the parts.
// -1  given motion partten.
//  0  still.
//  1  six DOF motion.
//  2  three DOF motion.
// 11  X-axis forced motion.
// 12  Y-axis forced motion.
// 13  Z-axis forced motion.
// 14  forced pitch motion.
// 15  forced yaw motion.
// 16  forced roll motion.
int  RBDMethod_0 = 0;
double amplitude_0 = 0.0;
double reduceFrequency_0 = 0.0;
int storeAleWalldis = 0;
// direction of rotation.
//         1 -- clockwise from the point of view along the positive x axis.
//        -1 -- anticlockwise from the point of view along the positive x axis.
int direction_0 = -1;
double rotateFrequency_0 = 0.0;
//string uDFSixDofFileName_0 = "./Bin/UDFSixDof.Parameter";
// dimensional physical time for additional force(s).
double addedForceTime_0[] = 0.0;
// dimensional massCenterPosition for additional force(s).
double addedForcePosition_0[] = 0.0, 0.0, 0.0;
// additional force(inertia system) fX fY fZ.  
double addedForce_0[] = 0.0, 0.0, 0.0;
// additional moment(inertia system) mX mY mZ.  
double addedMoment_0[] = 0.0, 0.0, 0.0;
// the deformation method of the parts.
int morphing_0 = 0;

// post indentify.
int integralOrder = 4;

#************************************************************************
#                         TurboMachinery Parameter                      *
#************************************************************************
// ----------------- Rotating Frame --------------------------------
// referenceFrame: whether rotating reference frame used.
//               0 -- Stationary Frame.
//               1 -- Translational Frame.
//               2 -- Rotational Frame.
int referenceFrame = 0;

// nTurboZone: number of rows of TurboMachinery.
int nTurboZone = 0;

// Periodic_Name: a list of periodic boundary name, the  number of name equals to 2*nZone
//                "Periodic_up, Periodic_down" means a pair of name of one zone
string Periodic_Name[] = "Periodic_up, Periodic_down";

// PeriodicRotationAngle means rotating angle for each zone.
// PeriodicRotationAngle[] = [theta1, theta2...]
//                theta1, theta2 means rotating angle for zone1,zone2.
double PeriodicRotationAngle[] = [16.363636363636];

// MixingPlane: a list of mixing plane name, the  number of name equals to 2*nZone-2
//                "MixOut, MixIn" the first is upstream zone outlet, the second is downstream zone inlet.
string MixingPlane[] = "";

// Omega: angular velocity(rad/s) of each zone.
double Omega[] = [-1680.0];

// shroud: define turbomachinery shroud of each zone, because shroud do not rotate.
string shroud[] = "shroud";

// nSpanSection: number of spanwise section used for mixing plane.
int nSpanSection = 0;

// ---------------- ATP read --------------------------------------------
//@int    inflowParaType = 0;
//@double refReNumber = 6.5e6;
//@double refDimensionalTemperature = 288.15;
//@double freestream_vibration_temperature = 300.00;
//@double refDimensionalPressure = 0;
//@double height                 = 0;
//@int nsubsonicInlet            = 0;
//@int nsubsonicOutlet           = 0;
//@string inLetFileName          = "./bin/subsonicInlet.hypara";
//@string outLetFileName         = "./bin/subsonicOutlet.hypara";
//@double refDimensionalVelocity = 0;
//@double refDimensionalDensity = 0;
//@string weatherDataFilePath   = "./WRFData/";
//@double longitude = 110.95    
//@double latitude = 19.61;
#************************************************************************
#                             Old Parameter                             *
#************************************************************************
int isPlotVolumeField = 0;

#************************************************************************
#                         partial flow field setting Parameter          *
#************************************************************************
//int nPartialParameter = 0;       // 0/1/2
//int nNumberOfPartialField = 0;   //   
//int nStartGridIndex[] = [0];
//int nEndGridIndex[] = [0];

//double partialCFL[] = [0.0];
//double partialSpeedCoef[] = [0.0];
//double partialSpeed[] = [0.0];
//double partialAttackd[] = [0.0];
//double partialSlide[] = [0.0];
//double partialPressure[] = [0.0];
//double partialTemperature[] = [0.0];
//double partialMassFractions[] = [0.0];

#************************************************************************
#                         Incompressible Parameter                      *
#************************************************************************
int isSolveEnergyEquation = 0;
int isSolveTurbEquation = 0;
int isSolveSpeciesEquation = 0;
