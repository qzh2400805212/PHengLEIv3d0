#include "LBMSolverMPI.hpp"

inline int indexM(int x, int y, int NX)
{
    return (y * NX) + x;
}

void LBM::iniMRT()
{
    double *Mtemp2 = new double[direction_size * direction_size];
    double *F_diag2 = new double[direction_size];

    if (velocity_set == "D2Q9")
    {
        double Mtemp[9][9] =
        {
            {	1.,  1., 1., 1.,  1., 1., 1., 1., 1.},    //! M11, M12, M13, M14, M15, ...
            {  -4., -1.,-1.,-1., -1., 2., 2., 2., 2.},
            {   4., -2.,-2.,-2., -2., 1., 1., 1., 1.},
            {   0.,  1., 0.,-1.,  0., 1.,-1.,-1., 1.},
            {   0., -2., 0., 2.,  0., 1.,-1.,-1., 1.},
            {   0.,  0., 1., 0., -1., 1., 1.,-1.,-1.},
            {   0.,  0.,-2., 0.,  2., 1., 1.,-1.,-1.},
            {   0.,  1.,-1., 1., -1., 0., 0., 0., 0.},
            {   0.,  0., 0., 0.,  0., 1.,-1., 1.,-1.}
        };
        double F_diag[9] = { 9.0, 36.0,36.0,6.0,12.0,6.0,12.0,4.0,4.0 };
        for (int i = 0; i < direction_size; i++)
        {
            F_diag2[i] = F_diag[i];
            for (int j = 0; j < direction_size; j++)
            {
                Mtemp2[indexM(i, j, direction_size)] = Mtemp[i][j];
            }
        }
    }
    else if (velocity_set == "D3Q15")
    {
        double Mtemp[15][15] =
        {
            //{  0   1   2   3   4   5   6   7   8   9  10  11  12  13  14 },
            { 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1},
            {-2 ,-1, -1 ,-1 ,-1 ,-1 ,-1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1},
            {16 ,-4, -4 ,-4 ,-4 ,-4 ,-4 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1},
            { 0 , 1 ,-1 , 0 , 0 , 0 , 0 , 1 ,-1 , 1 ,-1 , 1 ,-1 , 1 ,-1},
            { 0 ,-4 , 4 , 0 , 0 , 0 , 0 , 1 ,-1 , 1 ,-1 , 1 ,-1 , 1 ,-1},
            { 0 , 0 , 0 , 1 ,-1 , 0 , 0 , 1 , 1 ,-1 ,-1 , 1 , 1 ,-1 ,-1},
            { 0 , 0 , 0 ,-4 , 4 , 0 , 0 , 1 , 1 ,-1 ,-1 , 1 , 1 ,-1 ,-1},
            { 0 , 0 , 0 , 0 , 0 , 1 ,-1 , 1 , 1 , 1 , 1 ,-1 ,-1 ,-1 ,-1},
            { 0 , 0 , 0 , 0 , 0 ,-4 , 4 , 1 , 1 , 1 , 1 ,-1 ,-1 ,-1 ,-1},
            { 0 , 2 , 2 ,-1 ,-1 ,-1 ,-1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0},
            { 0 , 0 , 0 , 1 , 1 ,-1 ,-1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0},
            { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 ,-1 ,-1 , 1 , 1 ,-1 ,-1 , 1},
            { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 ,-1 ,-1 ,-1 ,-1 , 1 , 1},
            { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 ,-1 , 1 ,-1 ,-1 , 1 ,-1 , 1},
            { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 ,-1 ,-1 , 1 ,-1 , 1 , 1 ,-1}
        };
        double F_diag[15] = { 15.,18.,360.,10.,40.,10.,40.,10.,40.,12.,4.,8.,8.,8.,8. };
        for (int i = 0; i < direction_size; i++)
        {
            F_diag2[i] = F_diag[i];
            for (int j = 0; j < direction_size; j++)
            {
                Mtemp2[indexM(i, j, direction_size)] = Mtemp[i][j];
            }
        }
    }
    else if (velocity_set == "D3Q19")
    {
        double Mtemp[19][19] =
        {
            //{  0   1   2   3   4   5   6  7   8  9 10 11 12 13 14 15 16 17 18},
            {  1,  1,  1,  1,  1,  1,  1, 1,  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {-30,-11,-11,-11,-11,-11,-11, 8,  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8},
            { 12, -4, -4, -4, -4, -4, -4, 1,  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {  0,  1, -1,  0,  0,  0,  0, 1,  1,-1,-1, 1,-1, 1,-1, 0, 0, 0, 0},    //! ex
            {  0, -4,  4,  0,  0,  0,  0, 1,  1,-1,-1, 1,-1, 1,-1, 0, 0, 0, 0},
            {  0,  0,  0,  1, -1,  0,  0, 1, -1, 1,-1, 0, 0, 0, 0, 1, 1,-1,-1},    //! ey
            {  0,  0,  0, -4,  4,  0,  0, 1, -1, 1,-1, 0, 0, 0, 0, 1, 1,-1,-1},
            {  0,  0,  0,  0,  0,  1, -1, 0,  0, 0, 0, 1, 1,-1,-1, 1,-1, 1,-1},    //! ez
            {  0,  0,  0,  0,  0, -4,  4, 0,  0, 0, 0, 1, 1,-1,-1, 1,-1, 1,-1},
            {  0,  2,  2, -1, -1, -1, -1, 1,  1, 1, 1, 1, 1, 1, 1,-2,-2,-2,-2},
            {  0, -4, -4,  2,  2,  2,  2, 1,  1, 1, 1, 1, 1, 1, 1,-2,-2,-2,-2},
            {  0,  0,  0,  1,  1, -1, -1, 1,  1, 1, 1,-1,-1,-1,-1, 0, 0, 0, 0},
            {  0,  0,  0, -2, -2,  2,  2, 1,  1, 1, 1,-1,-1,-1,-1, 0, 0, 0, 0},
            {  0,  0,  0,  0,  0,  0,  0, 1, -1,-1, 1, 0, 0, 0, 0, 0, 0, 0, 0},
            {  0,  0,  0,  0,  0,  0,  0, 0,  0, 0, 0, 0, 0, 0, 0, 1,-1,-1, 1},
            {  0,  0,  0,  0,  0,  0,  0, 0,  0, 0, 0, 1,-1,-1, 1, 0, 0, 0, 0},
            {  0,  0,  0,  0,  0,  0,  0, 1,  1,-1,-1,-1, 1,-1, 1, 0, 0, 0, 0},
            {  0,  0,  0,  0,  0,  0,  0,-1,  1,-1, 1, 0, 0, 0, 0, 1, 1,-1,-1},
            {  0,  0,  0,  0,  0,  0,  0, 0,  0, 0, 0, 1, 1,-1,-1,-1, 1,-1, 1}
        };

        double F_diag[19] = { 19.0,2394.0,252.0,10.0,40.0,10.0,40.0,10.0,40.0,36.0,72.0,12.0,24.0,4.0,4.0,4.0,8.0,8.0,8.0 };
        for (int i = 0; i < direction_size; i++)
        {
            F_diag2[i] = F_diag[i];
            for (int j = 0; j < direction_size; j++)
            {
                Mtemp2[indexM(i, j, direction_size)] = Mtemp[i][j];
            }
        }
    }

    else if (velocity_set == "D3Q27")
    {   //! A D3Q27 multiple-relaxation-time lattice Boltzmann method for turbulent flows
        double Mtemp[27][27] =
        {
            {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
            {0,1,0,-1,0,0,0,1,-1,-1,1,1,0,-1,0,1,0,-1,0,1,-1,-1,1,1,-1,-1,1},    //! ex
            {0,0,1,0,-1,0,0,1,1,-1,-1,0,1,0,-1,0,1,0,-1,1,1,-1,-1,1,1,-1,-1},    //! ey
            {0,0,0,0,0,1,-1,0,0,0,0,1,1,1,1,-1,-1,-1,-1,1,1,1,1,-1,-1,-1,-1},    //! ez
            {-2,-1,-1,-1,-1,-1,-1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1},
            {0,2,-1,2,-1,-1,-1,1,1,1,1,1,-2,1,-2,1,-2,1,-2,0,0,0,0,0,0,0,0},
            {0,0,1,0,1,-1,-1,1,1,1,1,-1,0,-1,0,-1,0,-1,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,1,-1,1,-1,0,0,0,0,0,0,0,0,1,-1,1,-1,1,-1,1,-1},
            {0,0,0,0,0,0,0,0,0,0,0,0,1,0,-1,0,-1,0,1,1,1,-1,-1,-1,-1,1,1},
            {0,0,0,0,0,0,0,0,0,0,0,1,0,-1,0,-1,0,1,0,1,-1,-1,1,-1,1,1,-1},
            {0,-4,0,4,0,0,0,-1,1,1,-1,-1,0,1,0,-1,0,1,0,2,-2,-2,2,2,-2,-2,2},
            {0,0,-4,0,4,0,0,-1,-1,1,1,0,-1,0,1,0,-1,0,1,2,2,-2,-2,2,2,-2,-2},
            {0,0,0,0,0,-4,4,0,0,0,0,-1,-1,-1,-1,1,1,1,1,2,2,2,2,-2,-2,-2,-2},
            {0,4,0,-4,0,0,0,-2,2,2,-2,-2,0,2,0,-2,0,2,0,1,-1,-1,1,1,-1,-1,1},
            {0,0,4,0,-4,0,0,-2,-2,2,2,0,-2,0,2,0,-2,0,2,1,1,-1,-1,1,1,-1,-1},
            {0,0,0,0,0,4,-4,0,0,0,0,-2,-2,-2,-2,2,2,2,2,1,1,1,1,-1,-1,-1,-1},
            {4,0,0,0,0,0,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,1,1,1,1,1,1,1},
            {-8,4,4,4,4,4,4,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,1,1,1,1,1,1,1,1},
            {0,-4,2,-4,2,2,2,1,1,1,1,1,-2,1,-2,1,-2,1,-2,0,0,0,0,0,0,0,0},
            {0,0,-2,0,-2,2,2,1,1,1,1,-1,0,-1,0,-1,0,-1,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,-2,2,-2,2,0,0,0,0,0,0,0,0,1,-1,1,-1,1,-1,1,-1},
            {0,0,0,0,0,0,0,0,0,0,0,0,-2,0,2,0,2,0,-2,1,1,-1,-1,-1,-1,1,1},
            {0,0,0,0,0,0,0,0,0,0,0,-2,0,2,0,2,0,-2,0,1,-1,-1,1,-1,1,1,-1},
            {0,0,0,0,0,0,0,1,-1,-1,1,-1,0,1,0,-1,0,1,0,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,-1,-1,1,1,0,1,0,-1,0,1,0,-1,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,1,-1,1,-1,-1,1,-1,1,0,0,0,0,0,0,0,0},
            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,-1,1,-1,-1,1,-1,1}
        };

        double F_diag[27] = { 27.,18.,18,18,18,36,12,12,12,12,72,72,72,72,72,72,36,216,72,24,24,24,24,8,8,8,8 };
        for (int i = 0; i < direction_size; i++)
        {
            F_diag2[i] = F_diag[i];
            for (int j = 0; j < direction_size; j++)
            {
                Mtemp2[indexM(i, j, direction_size)] = Mtemp[i][j];
            }
        }
    }
    M_MRT = new double* [direction_size];
    M_MRTI = new double* [direction_size];
    MSM = new double* [direction_size];
    for (int i = 0; i < direction_size; i++)
    {
        M_MRT[i] = new double[direction_size];
        M_MRTI[i] = new double[direction_size];
        MSM[i] = new double[direction_size];
        for (int j = 0; j < direction_size; j++)
        {
            M_MRT[i][j] = Mtemp2[indexM(i, j, direction_size)];
        }
    }
    for (int j = 0; j < direction_size; j++)
    {
        for (int i = 0; i < direction_size; i++)
        {
            M_MRTI[j][i] = M_MRT[i][j] / F_diag2[i];
        }
    }
    calculate_MSM(tau);
}

void LBM::calculate_MSM(double tau)
{
    double *Inv_MS = new double[direction_size * direction_size];
    double *S_diag2 = new double[direction_size];

    if (velocity_set == "D2Q9")
    {
        double S_diag[9] = { 1.64, 1.64, 1.54, 1.6, 1.9, 1.6, 1.9, 1., 1. };    //! s0, ...s8, s8 = s7, s2 = 1.54, s4 = s6 = 1.9
        S_diag[7] = 1.0 / tau;
        S_diag[8] = S_diag[7];
        for (int i = 0; i < direction_size; i++)
        {
            S_diag2[i] = S_diag[i];
        }
    }
    else if (velocity_set == "D3Q15")
    {
        double S_diag[15] = { 0.0, 1.6,1.2,0.0,1.6,0.0,1.6,0.0,1.6, 1.0,1.0,1.0,1.0,1.0,1.2 };
        S_diag[9] = 1.0 / tau;
        S_diag[10] = S_diag[9];
        S_diag[11] = S_diag[9];
        S_diag[12] = S_diag[9];
        S_diag[13] = S_diag[9];
        for (int i = 0; i < direction_size; i++)
        {
            S_diag2[i] = S_diag[i];
        }
    }
    else if (velocity_set == "D3Q19")
    {
        double S_diag[19] = { 0.0, 1.19,1.4,0.0,1.2,0.0,1.2,0.0,1.2,1.0,1.4,1.0,1.4,1.0,1.0,1.0,1.98,1.98,1.98 };
        S_diag[9] = 1.0 / tau;
        S_diag[11] = S_diag[9];
        S_diag[13] = S_diag[9];
        S_diag[14] = S_diag[9];
        S_diag[15] = S_diag[9];
        for (int i = 0; i < direction_size; i++)
        {
            S_diag2[i] = S_diag[i];
        }
    }
    else if (velocity_set == "D3Q27")
    {
        double s4, s5, s7, s10, s13, s16, s17, s18, s20, s23, s26;
        s5 = 1.0 / tau;
        s7 = 1.0 / tau;
        s4 = 1.54; s10 = 1.5; s13 = 1.83; s16 = 1.4; s17 = 1.61;
        s18 = s20 = 1.98; s23 = s26 = 1.74;
        double S_diag[27] = { 0, 0, 0, 0, s4, s5, s5, s7, s7, s7, s10, s10, s10, s13, s13, s13, s16, s17, s18, s18, s20, s20, s20, s23, s23, s23, s26 };

        for (int i = 0; i < direction_size; i++)
        {
            S_diag2[i] = S_diag[i];
        }
    }

    for (int i = 0; i < direction_size; i++)
    {
        for (int j = 0; j < direction_size; j++)
        {
            Inv_MS[indexM(i, j, direction_size)] = -M_MRTI[i][j] * S_diag2[j];
        }
    }
    for (int j = 0; j < direction_size; j++)
    {
        for (int i = 0; i < direction_size; i++)
        {
            MSM[i][j] = 0.0;
            for (int k = 0; k < direction_size; k++)
            {
                MSM[i][j] = MSM[i][j] + Inv_MS[indexM(i, k, direction_size)] * M_MRT[k][j];
            }
        }
    }
    delete [] Inv_MS;    Inv_MS = nullptr;
    delete [] S_diag2;    S_diag2 = nullptr;
}